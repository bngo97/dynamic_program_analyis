PARSER_BEGIN(MyParser)
import java.io.StringReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class MyParser
{
    public static void main(String[] args) throws FileNotFoundException {
        if(args.length != 2) {
            throw new RuntimeException("Incorrect command arguments");
        }
        MyParser parser;
        if(args[0].equals("-t")) {
            parser = new MyParser(new StringReader(args[1]));
        } else if(args[0].equals("-f")) {
            File file = new File(args[1]);
            parser = new MyParser(new FileInputStream(file));
        } else {
            throw new RuntimeException("Incorrect input flag");
        }
        try {
            NodeProg p = parser.Prog();
            System.out.println(p.name);
            System.out.println("Success!");
        } catch(Exception e) {
            System.out.println("Syntax check failed:");
            System.out.println(e.getMessage());
        }
    }
}
PARSER_END(MyParser)

SKIP: { " " }
SKIP: { "\n" }
SKIP: { "\r" }
SKIP: { "\t" }
SKIP: {<"//" (~["\n","\r"])* ("\n"|"\r")>}

TOKEN: { <PROG: "program"> }
TOKEN: { <CONST: "const"> }

TOKEN: { <ENUM: "enum"> }
TOKEN: { <CLASS: "class">}
TOKEN: { <INTERFACE: "interface"> }
TOKEN: { <EXTENDS: "extends"> }
TOKEN: { <IMPLEMENTS: "implements"> }
TOKEN: { <VOID: "void"> }
TOKEN: { <NEW: "new"> }
TOKEN: { <IF: "if"> }
TOKEN: { <ELSE: "else"> }
TOKEN: { <FOR: "for"> }
TOKEN: { <BREAK: "break"> }
TOKEN: { <CONTINUE: "continue"> }
TOKEN: { <RETURN: "return"> }
TOKEN: { <READ: "read"> }
TOKEN: { <PRINT: "print"> }

TOKEN: { <PLUS: "+"> }
TOKEN: { <MINUS: "-"> }

TOKEN: { <TIMES: "*"> }
TOKEN: { <DIV: "/"> }
TOKEN: { <MOD: "%"> }

TOKEN: { <EQ: "="> }

TOKEN: { <EQEQ: "=="> }
TOKEN: { <NOTEQ: "!="> }
TOKEN: { <GR: ">"> }
TOKEN: { <GRE: ">="> }
TOKEN: { <LE: "<"> }
TOKEN: { <LEQ: "<="> }

TOKEN: { <AND: "&&"> }
TOKEN: { <OR: "||"> }

TOKEN: { <PLUSx2: "++"> }
TOKEN: { <MINUSx2: "--"> }

TOKEN: { <NUM: (["0"-"9"])+ > }
TOKEN: { <BOOL: ( "true" | "false" )>}
TOKEN: { <CHAR: "'"[" " - "~"]"'">}
TOKEN: { <IDENT: (["a"-"z"] | ["A"-"Z"]) (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | "_")*>}

NodeProg Prog(): {
    Token n;
    NodeProg p;
} {
    <PROG> n=<IDENT>
    (
        ConstDecl() |
        EnumDecl() |
        VarDecl() |
        ClassDecl() |
        InterfaceDecl()
     )*
    "{"
    (
        MethodDecl()
    )*
    "}" <EOF>
    {
        return new NodeProg(n.image);
    }
}

NodeConstDecl ConstDecl(): {} { <CONST> Type() <IDENT> <EQ> ( <NUM> | <BOOL> | <CHAR> ) ("," <IDENT> <EQ> ( <NUM> | <BOOL> | <CHAR> ))* ";" }

void EnumDecl(): {} { <ENUM> <IDENT> "{" <IDENT> [<EQ><NUM>] ("," <IDENT> [<EQ><NUM>])*"}" }

void VarDecl(): {} { Type() <IDENT> ["[" "]"] ("," <IDENT> ["[" "]"])* ";" }

void InterfaceDecl(): {} { <INTERFACE> <IDENT> "{" (InterfaceMethodDecl())* "}" }

void InterfaceMethodDecl(): {} { (Type() | <VOID>) <IDENT> "(" [FormPars()] ")" ";"}

void FormPars(): {} { Type() <IDENT> ["[" "]"] ("," Type() <IDENT> ["[" "]"])* }

void ClassDecl(): {} { <CLASS> <IDENT> [<EXTENDS> Type()] [<IMPLEMENTS> Type() ("," Type())* ] "{" (VarDecl())* ["{" (MethodDecl())* "}"] "}"}

void MethodDecl(): {} { (Type() | <VOID>) <IDENT> "(" [FormPars()] ")" (VarDecl())* "{" (Statement())* "}"}

void Type(): {} { <IDENT> }

void Statement(): {} {
    (DesignatorStatement() ";") |
    (<IF> "(" Condition() ")" Statement() [<ELSE> Statement()]) |
    (<FOR> "(" [DesignatorStatement()] ";" [Condition()] ";" [DesignatorStatement()] ")" Statement()) |
    (<BREAK> ";") |
    (<CONTINUE> ";") |
    (<RETURN> [Expr()] ";") |
    (<READ> "(" Designator() ")" ";") |
    (<PRINT> "(" Expr() ["," <NUM>] ")" ";") |
    ("{" (Statement())* "}")
}

void DesignatorStatement(): {} { Designator() ((Assignop() Expr()) | ("(" [ActPars()] ")") | <PLUSx2> | <MINUSx2>) }

void Designator(): {} { <IDENT> (("." <IDENT>) | ("[" Expr() "]"))*}

void Condition(): {} { CondTerm() (<OR> CondTerm())* }

void CondTerm(): {} { CondFact() (<AND> CondFact())* }

void CondFact(): {} { Expr() [Relop() Expr()] }

void Expr(): {} { [ <MINUS> ] Term() (Addop() Term())* }

void Term(): {} { Factor() (Mulop() Factor())* }

void Factor(): {} { ( (Designator() ["(" [ActPars()] ")"]) | (<NUM>) | (<CHAR>) | <BOOL> | (<NEW> Type() ["[" Expr() "]"])) }

void ActPars(): {} { Expr() ("," Expr())* }

void Assignop(): {} { <EQ> }

void Relop(): {} { ( <EQEQ> | <NOTEQ> | <GR> | <GRE> | <LE> | <LEQ>) }

void Addop(): {} { ( <PLUS> | <MINUS> ) }

void Mulop(): {} { ( <TIMES> | <DIV> | <MOD> ) }