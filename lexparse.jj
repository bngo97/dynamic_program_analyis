PARSER_BEGIN(MyParser)
import java.io.StringReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

public class MyParser
{
    public static void main(String[] args) throws FileNotFoundException {
        if(args.length != 2) {
            throw new RuntimeException("Incorrect command arguments");
        }
        MyParser parser;
        if(args[0].equals("-t")) {
            parser = new MyParser(new StringReader(args[1]));
        } else if(args[0].equals("-f")) {
            File file = new File(args[1]);
            parser = new MyParser(new FileInputStream(file));
        } else {
            throw new RuntimeException("Incorrect input flag");
        }
        try {
            NodeProg p = parser.Prog();
//            for(NodeConstDecl n : p.constDecls) {
//                System.out.println(n);
//            }
//            for(NodeEnumDecl n : p.enumDecls) {
//                System.out.println(n);
//            }
//            for(NodeVarDecl n : p.varDecls) {
//                System.out.println(n);
//            }
            for(NodeClassDecl n : p.classDecls) {
                System.out.println(n);
            }
            System.out.println("Success!");
        } catch(Exception e) {
            System.out.println("Syntax check failed:");
            System.out.println(e.getMessage());
        }
    }
}
PARSER_END(MyParser)

SKIP: { " " }
SKIP: { "\n" }
SKIP: { "\r" }
SKIP: { "\t" }
SKIP: {<"//" (~["\n","\r"])* ("\n"|"\r")>}

TOKEN: { <PROG: "program"> }
TOKEN: { <CONST: "const"> }

TOKEN: { <ENUM: "enum"> }
TOKEN: { <CLASS: "class">}
TOKEN: { <INTERFACE: "interface"> }
TOKEN: { <EXTENDS: "extends"> }
TOKEN: { <IMPLEMENTS: "implements"> }
TOKEN: { <VOID: "void"> }
TOKEN: { <NEW: "new"> }
TOKEN: { <IF: "if"> }
TOKEN: { <ELSE: "else"> }
TOKEN: { <FOR: "for"> }
TOKEN: { <BREAK: "break"> }
TOKEN: { <CONTINUE: "continue"> }
TOKEN: { <RETURN: "return"> }
TOKEN: { <READ: "read"> }
TOKEN: { <PRINT: "print"> }

TOKEN: { <PLUS: "+"> }
TOKEN: { <MINUS: "-"> }

TOKEN: { <TIMES: "*"> }
TOKEN: { <DIV: "/"> }
TOKEN: { <MOD: "%"> }

TOKEN: { <EQ: "="> }

TOKEN: { <EQEQ: "=="> }
TOKEN: { <NOTEQ: "!="> }
TOKEN: { <GR: ">"> }
TOKEN: { <GRE: ">="> }
TOKEN: { <LE: "<"> }
TOKEN: { <LEQ: "<="> }

TOKEN: { <AND: "&&"> }
TOKEN: { <OR: "||"> }

TOKEN: { <PLUSx2: "++"> }
TOKEN: { <MINUSx2: "--"> }

TOKEN: { <NUM: (["0"-"9"])+ > }
TOKEN: { <BOOL: ( "true" | "false" )>}
TOKEN: { <CHAR: "'"[" " - "~"]"'">}
TOKEN: { <IDENT: (["a"-"z"] | ["A"-"Z"]) (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | "_")*>}

NodeProg Prog(): {
    Token id;
    List<NodeConstDecl> constDecls = new ArrayList<NodeConstDecl>();
    List<NodeConstDecl> constDecl = null;
    List<NodeEnumDecl> enumDecls = new ArrayList<NodeEnumDecl>();
    NodeEnumDecl enumDecl = null;
    List<NodeVarDecl> varDecls = new ArrayList<NodeVarDecl>();
    List<NodeVarDecl> varDecl = null;
    List<NodeClassDecl> classDecls = new ArrayList<NodeClassDecl>();
    NodeClassDecl classDecl = null;
} {
    <PROG> id=<IDENT>
    (
        constDecl=ConstDecl() { constDecls.addAll(constDecl); } |
        enumDecl=EnumDecl() { enumDecls.add(enumDecl); } |
        varDecl=VarDecl() { varDecls.addAll(varDecl); } |
        classDecl=ClassDecl() { classDecls.add(classDecl); } |
        InterfaceDecl()
     )*

    "{"
    (
        MethodDecl()
    )*
    "}" <EOF>
    {
        return new NodeProg(id.image, constDecls, enumDecls, varDecls, classDecls);
    }
}

List<NodeConstDecl> ConstDecl(): {
    List<NodeConstDecl> decls = new ArrayList<NodeConstDecl>();
    Token n, v;
    String t;
} {
    <CONST> t=Type() n=<IDENT> <EQ> ( v=<NUM> | v=<BOOL> | v=<CHAR> ) { decls.add(new NodeConstDecl(t, n.image, v.image)); }
    ("," n=<IDENT> <EQ> ( v=<NUM> | v=<BOOL> | v=<CHAR> ) { decls.add(new NodeConstDecl(t, n.image, v.image)); })* ";"
    {
        return decls;
    }
}

NodeEnumDecl EnumDecl(): {
    Token id;
    Token key = null, val = null;
    Map<String, String> vals = new HashMap<String, String>();
} { <ENUM> id=<IDENT> "{" key=<IDENT> [<EQ> val=<NUM>] {vals.put(key.image, val == null ? null : val.image); val = null;} ("," key=<IDENT> [<EQ> val=<NUM>] {vals.put(key.image, val == null ? null : val.image); val = null;})*"}"
    {
        return new NodeEnumDecl(id.image, vals);
    }
}

List<NodeVarDecl> VarDecl(): {
    List<NodeVarDecl> decls = new ArrayList<NodeVarDecl>();
    String t;
    Token id;
} { t=Type() id=<IDENT> ["[" "]"] { decls.add(new NodeVarDecl(t, id.image)); } ("," id=<IDENT> ["[" "]"] { decls.add(new NodeVarDecl(t, id.image)); } )* ";"
    {
        return decls;
    }
}

void InterfaceDecl(): {} { <INTERFACE> <IDENT> "{" (InterfaceMethodDecl())* "}" }

void InterfaceMethodDecl(): {} { (Type() | <VOID>) <IDENT> "(" [FormPars()] ")" ";"}

Map<String,String> FormPars(): {
    Map<String,String> formPars = new HashMap<String,String>();
    String type;
    Token id;
} { type=Type() id=<IDENT> { formPars.put(id.image, type); } ["[" "]"] ("," type=Type() id=<IDENT> ["[" "]"] { formPars.put(id.image, type); })*
    {
        return formPars;
    }
}

NodeClassDecl ClassDecl(): {
    Token id;
    String parent = null;
    String impl = null;
    List<String> impls = new ArrayList<String>();
    List<NodeVarDecl> vars = new ArrayList<NodeVarDecl>();
    List<NodeVarDecl> var = null;
    List<NodeMethodDecl> methods = new ArrayList<NodeMethodDecl>();
    NodeMethodDecl method = null;
} { <CLASS> id=<IDENT> [<EXTENDS> parent=Type()] [<IMPLEMENTS> impl=Type() { impls.add(impl); } ("," impl=Type() { impls.add(impl); })* ]
    "{"
        (var=VarDecl() { vars.addAll(var); } )*
    ["{"
        (method=MethodDecl() { methods.add(method); } )*
    "}"]
    "}"
    {
        return new NodeClassDecl(id.image, parent, impls, vars, methods);
    }
}

NodeMethodDecl MethodDecl(): {
    String returnType = null;
    Token id;
    Map<String,String> formPars = new HashMap<String, String>();
    List<NodeVarDecl> vars = new ArrayList<NodeVarDecl>();
    List<NodeVarDecl> var = null;
} { (returnType=Type() | <VOID>) { if(returnType == null) returnType = "void"; } id=<IDENT> "(" [formPars=FormPars()] ")"
    (var=VarDecl() { vars.addAll(var); })*
    "{"
        (Statement())*
    "}"
    {
        return new NodeMethodDecl(id.image, returnType, formPars, vars);
    }
}

String Type(): {Token id;} { id=<IDENT> { return id.image; } }

void Statement(): {} {
    (DesignatorStatement() ";") |
    (<IF> "(" Condition() ")" Statement() [<ELSE> Statement()]) |
    (<FOR> "(" [DesignatorStatement()] ";" [Condition()] ";" [DesignatorStatement()] ")" Statement()) |
    (<BREAK> ";") |
    (<CONTINUE> ";") |
    (<RETURN> [Expr()] ";") |
    (<READ> "(" Designator() ")" ";") |
    (<PRINT> "(" Expr() ["," <NUM>] ")" ";") |
    ("{" (Statement())* "}")
}

void DesignatorStatement(): {} { Designator() ((Assignop() Expr()) | ("(" [ActPars()] ")") | <PLUSx2> | <MINUSx2>) }

void Designator(): {} { <IDENT> (("." <IDENT>) | ("[" Expr() "]"))*}

void Condition(): {} { CondTerm() (<OR> CondTerm())* }

void CondTerm(): {} { CondFact() (<AND> CondFact())* }

void CondFact(): {} { Expr() [Relop() Expr()] }

void Expr(): {} { [ <MINUS> ] Term() (Addop() Term())* }

void Term(): {} { Factor() (Mulop() Factor())* }

void Factor(): {} { ( (Designator() ["(" [ActPars()] ")"]) | (<NUM>) | (<CHAR>) | <BOOL> | (<NEW> Type() ["[" Expr() "]"])) }

void ActPars(): {} { Expr() ("," Expr())* }

void Assignop(): {} { <EQ> }

void Relop(): {} { ( <EQEQ> | <NOTEQ> | <GR> | <GRE> | <LE> | <LEQ>) }

void Addop(): {} { ( <PLUS> | <MINUS> ) }

void Mulop(): {} { ( <TIMES> | <DIV> | <MOD> ) }